# ****02_Protocol FTP & SSH****

---

## 1. **FTP(File Transfer Protocol)**

1. **FTP란??**

FTP는 파일 전송 프로토콜(File Transfer Protocol)의 약자로,
컴퓨터 네트워크를 통해 파일을 전송하기 위해 사용되는 표준 프로토콜입니다.

    FTP는 클라이언트-서버 모델을 기반으로 작동합니다. 
    클라이언트는 FTP 클라이언트 소프트웨어( FileZilla 등 )를 사용하여 서버로 연결하고, 
    서버는 FTP 서버 소프트웨어를 사용하여 클라이언트의 요청을 처리합니다. 
    이를 통해 파일의 업로드, 다운로드, 삭제, 이동 등의 작업을 수행할 수 있습니다.
    
    FTP는 기본적으로 TCP/IP 프로토콜 스택을 사용하며, 기본 포트 번호는 21번입니다. 
    FTP는 암호화되지 않기 때문에, 보안을 강화하기 위해 
    SSL(Secure Sockets Layer)이나 TLS(Transport Layer Security)와 같은 
    보안 계층을 추가하여 FTPS(File Transfer Protocol Secure)로 사용할 수 있습니다.

2. **명령어와 응답 코드**

FTP는 다양한 명령어와 응답 코드를 사용하여 클라이언트와 서버 간의 상호작용을 담당합니다.
명령어는 클라이언트가 서버에게 보내는 요청을 나타내며,
응답 코드는 서버가 클라이언트에게 반환하는 상태를 나타냅니다.
몇 가지 일반적인 FTP 명령어와 응답 코드는 다음과 같습니다

    1. **USER**: 서버에 사용자 이름을 보내 인증을 위해 사용됩니다.
    2. **PASS**: 서버에 사용자 비밀번호를 보내 인증을 완료합니다.
    3. **LIST**: 서버의 디렉토리 내용을 나열합니다.
    4. **RETR**: 서버에서 파일을 클라이언트로 다운로드합니다.
    5. **STOR**: 클라이언트에서 서버로 파일을 업로드합니다.
    6. **DELE**: 서버에서 파일을 삭제합니다.
    7. **MKD**: 서버에 새 디렉토리를 생성합니다.
    8. **RMD**: 서버에서 디렉토리를 삭제합니다.

3. Linxu Terminal 에서의 샘플 코드
    1. Linux 터미널에서 FTP를 사용하기 위해선 **`ftp`** 명령어를 사용할 수 있습니다.
    2. 서버에 연결하기: **`ftp <서버 주소>`**

        ```bash
        ftp [example.com](http://example.com/)
        ```

    3. 사용자 인증 : `user <사용자 이름> <비밀번호>`

        ```bash
        user username password
        ```

    4. 서버의 현재 디렉토리 내용 나열 : `ls`

        ```bash
        ls
        ```

    5. 파일 다운로드: **`get <원격 파일> [<로컬 파일>]`**

        ```bash
        get file.txt
        ```

    6. 파일 업로드: **`put <로컬 파일> [<원격 파일>]`**

        ```bash
        put file.txt
        ```

    7. 서버와의 연결 종료: **`bye`**

        ```bash
        bye
        ```


4. Java Sample Code ( Apache Commons Net )

    ```java
    import org.apache.commons.net.ftp.FTP;
    import org.apache.commons.net.ftp.FTPClient;
    
    import java.io.*;
    
    public class FTPExample {
        public static void main(String[] args) {
            // 연결할 FTP 서버의 호스트 주소
            String server = "ftp.example.com";
            // FTP 서버의 포트
            int port = 21;
            // 사용자 정보
            String user = "username";
            String pass = "password";
            // FTP Client 객체 생성
            FTPClient ftpClient = new FTPClient();
    
            try {
                // FTP 서버에 연결
                ftpClient.connect(server, port);
                // 사용자 인증
                ftpClient.login(user, pass);
    
                // Passive 모드로 설정
                ftpClient.enterLocalPassiveMode();
                // 전송 파일 유형 설정 (BINARY_FILE_TYPE은 이진 파일 전송을 의미)
                ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
    
                // 다운로드할 원격 파일 경로와 로컬 파일 객체 생성
                String remoteFile = "/path/to/remote/file.txt";
                File localFile = new File("/path/to/local/file.txt");
    
                // 로컬 파일로 데이터를 전송받기 위한 OutputStream 생성
                OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(localFile));
                // 원격 파일을 로컬 파일로 다운로드
                boolean success = ftpClient.retrieveFile(remoteFile, outputStream);
                outputStream.close();
    
                // 다운로드 성공 여부 확인
                if (success) {
                    System.out.println("File has been downloaded successfully.");
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    // FTP 연결 종료
                    if (ftpClient.isConnected()) {
                        ftpClient.logout();
                        ftpClient.disconnect();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    ```

## 2. **SSH ( Secure Shell )**

1. SSH란??

   SSH는 Secure Shell의 약자로,
   네트워크를 통해 안전하게 원격으로 로그인하고 컴퓨터를 제어하기 위한 프로토콜 및
   해당 프로토콜을 구현한 프로그램입니다.

   SSH는 암호화 기술을 사용하여 네트워크 연결을 보호합니다.
   이를 통해 사용자는 원격으로 안전하게 서버에 로그인하고 명령을 실행할 수 있습니다.
   SSH는 클라이언트-서버 모델을 기반으로 작동하며, 일반적으로 22번 포트를 사용합니다.

   SSH는 데이터 전송, 원격 제어, 파일 전송 등 다양한 용도로 사용됩니다.
   SSH는 비밀번호 인증뿐만 아니라 공개 키 인증 방식도 지원하여 보안성을 강화할 수 있습니다.
   SSH는 네트워크 보안을 위해 광범위하게 사용되며,
   FTP와 달리 데이터를 암호화하여 안전한 전송을 보장합니다.

   SSH는 다양한 운영체제에서 지원되며, 주로 Linux 및 Unix 시스템에서 널리 사용됩니다.
   SSH 클라이언트 및 서버는 OpenSSH, PuTTY, SecureCRT 등 다양한 소프트웨어로 구현되어 있습니다.

2. SSH 주요 기능
    1. **보안 연결**
       SSH는 암호화 기술을 사용하여 클라이언트와 서버 간의 통신을 암호화합니다.
       이를 통해 데이터의 기밀성과 무결성을 보호하며 중간에서의 도청이나 데이터 변조를 방지합니다.
    2. **사용자 인증**
       SSH는 비밀번호 인증뿐만 아니라 공개 키 기반의 인증 방식도 지원합니다.
       공개 키를 사용한 인증은 보안성을 높이고 비밀번호를 입력하지 않고도 안전하게 로그인할 수 있습니다.
    3. **원격 제어**
       SSH를 사용하면 원격 서버에 접속하여 명령을 실행하고 원격으로 컴퓨터를 제어할 수 있습니다.
       SSH 클라이언트를 사용하여 원격 서버에 로그인하면
       원격 환경에서 명령어를 실행하거나 파일을 조작할 수 있습니다.
    4. **파일 전송**
       SSH는 파일 전송을 위한 SCP(Secure Copy)와 SFTP(SSH File Transfer Protocol)를 지원합니다. 이를 통해 파일을 안전하게 원격 서버로 전송하거나 원격 서버에서 로컬로
       다운로드할 수 있습니다.

3. SSH 동작 원리
    1. SSH 프로토콜은 클라이언트-서버 모델로 동작하며**대칭키 방식, 비대칭키 방식, 해시 알고리즘을 사용**하여 인증 및 암호화를 수행한다.
    2. **대칭키 방식은 클라이언트-서버 간 전체 연결을 암호화에 사용**되며
    3. **비대칭키 방식은 키 교환, 클라이언트 인증, 서버 인증에 사용**되고,
    4. **해시 알고리즘은 패킷의 무결성을 확인하기 위해 사용**된다.
       (HMAC: Hash based Message Authenticated Codes)

4. SSH 동작 과정
    1. **클라이언트는 서버에 원격 접속하기 위해 연결을 설정하는 프로세스를 시작한다.**
        1. SSH 프로토콜은 기본적(Default)으로 TCP 22번 포트를 사용하여 통신한다.
        2. 클라이언트가 서버에 원격 접속하기 위해
           서버의 TCP 22번 포트로 SSH 접속 요청을 보내는 것이 SSH 연결의 첫 단계이다.
        3. 서버는 클라이언트에게 서버가 지원하는 프로토콜의 버전을 응답으로 보내준다.
        4. 클라이언트는**서버가 지원하는 프로토콜의 버전 중
           자신과 일치하는 것이 있다면 연결을 지속**한다.**(버전 교환)**

    2. **서버는 자신의 공개키를 클라이언트에게 전송한다.**
        1. 서버는 클라이언트로부터 SSH 접속 요청을 받고
           자신의 공개키를 클라이언트에게 응답하고
           클라이언트는 서버로부터 받은 공개키를 로컬에 저장한다.
        2. 클라이언트는 원격 접속하는 서버들의 공개키를
           로컬 사용자 홈 디렉터리의 .ssh 경로 내의 known_hosts 파일에 저장하고 있다.

            ```
            ※ 클라이언트 사용자의 known_hosts 경로(Default)
            
            <Linux>
            일반계정  : /home/USER/.ssh/known_hosts
            root 계정 : /root/.ssh/known_hosts
            
            <Window>
            사용자    : %USERNAME%\.ssh\known_hosts
            ```

    3. **클라이언트와 서버는 여러 Parameter들을 주고 받으며 보안 채널을 확립한다.**
        1. **[ Client 1 ] 올바른 서버인지 확인**
            1. 클라이언트는 SSH로 원격 접속하려고 하는 서버가 올바른 서버인지 확인할 필요가 있다.
            2. 이를 위해 클라이언트는 known_hosts 파일에 존재하는 서버의 공개키를 통해 정상적인 서버인지 확인하는 작업을 수행한다.
            3. 확인 단계는 다음과 같다.
                1. 클라이언트에서 난수 생성, 난수 해시값 생성 및 저장
                2. 난수를 서버의 공개키로 암호화 후 서버에 전송
                3. 서버에서 서버의 개인키로 데이터를 복호화하여 난수 추출
                4. 서버에서 복호화된 난수 해시값을 생성 후 클라이언트에게 전송
                5. 클라이언트에 저장된 난수 해시값과 서버에서 받은 난수 해시값을 비교
                6. 동일할 시 올바른 서버 확인

        2. **[ Client 2 ] 암호화된 통신을 위한 세션키 생성 (대칭키 생성)**
            1. **세션키는 대칭키**로 전체 세션을 암호화하는데 사용되며**모든 통신을 암호화**한다.
            2. 대칭키는 비대칭키에 비해 빠르고 컴퓨팅 파워가 더 적게 든다는 장점을 가지고 있다.
            3. 그러나 대칭키가 유출되었을 경우
               공격자가 암호화된 모든 통신을 복호화할 수 있는 치명적인 문제점을 가지고 있다.
            4. 이를 해결하기 위해 클라이언트와 서버는
               **키 교환 알고리즘**을 통해 안전하게 대칭키를 공유한다.

               > **디피-헬만( Diffie-Hellman / DH ) Algorithm**
               >
               > 1. SSH에서 사용하는 대표적인**키교환 알고리즘인 DH 알고리즘**은
                    > 상대방의 공개키(비대칭 키)와 나의 개인키를 통해 대칭키를 얻어내는 방법이다.
            5. 클라이언트와 서버는
               임시 공개키( 임시 개인키와 해당 개인키에 대한 공개키 ) 방식의 키 쌍을 생성합니다.
               이 과정에서 클라이언트와 서버는 각자의 개인키와 공개키를 생성합니다.
            6. 클라이언트는 자신의 공개키를 서버에게 전달하고,
               서버는 자신의 공개키를 클라이언트에게 전달합니다.
               이를 통해 상대방의 공개키를 얻을 수 있습니다.
            7. 클라이언트는 상대방의 공개키와 자신의 개인키를 사용하여
               공유 비밀값(Shared Secret)을 계산합니다.
               이 비밀값은 대칭키로 사용될 수 있는데,
               클라이언트와 서버는 동일한 비밀값을 얻게 됩니다.
            8. 클라이언트와 서버는 얻어낸 공유 비밀값을 대칭키인 세션키로 사용하여
               암호화된 통신을 수행합니다.
               이후 모든 데이터는 대칭키를 사용하여 암호화되고 복호화됩니다.

               즉, DH 알고리즘을 통해 클라이언트와 서버는
               상대방의 공개키와 자신의 개인키를 이용하여 공유 비밀값을 계산하고,
               이 비밀값을 대칭키로 사용하여 통신을 암호화합니다.
               이로써 클라이언트와 서버는 대칭키인 세션키를 공유하게 되는 것입니다.

            9. **[주의] 대칭키 교환에 사용되는 키 쌍은
               서버와 클라이언트 인증에 사용되는 SSH 키 쌍과 다름**

               > SSH가 DH를 통해 얻은 대칭키는**개별 세션에 대해 생성되며 더 이상 필요하지 않은 즉시 사라진다.**
               >
               >
               > 따라서 클라이언트나 서버의 개인키가 유출되어도
               > 이전 세션키를 통해 수행한 통신 내용을 복호화할 수 없다.
               >
               > 이는 TLS 세션에서도 사용되는 구성으로 인증서에 만료 날짜가 있는 경우
               > 개인키는 중간자 공격으로 인해 유출되어도 인증서가 만료되었을 시
               > 사용할 수 없으므로 만료 후에는 강한 보안 유지를 하지 않아도 된다
   >

    4. **[ Server ]** **서버에 접근할 수 있는 클라이언트인지 확인**
        1. 서버 또한 자신에게 접속하려는 클라이언트가
           자신에게 접근할 수 있는 권한이 있는지 확인하는 단계가 필요하다.
        2. 가장 간단한 방법으로**패스워드 인증**이 있다.
        3. 서버는 단순히 로그인하려는 계정의 암호를 묻고
           클라이언트가 입력한 비밀번호는 세션키를 통해 암호화되고 전송되어
           외부로부터 안전하게 보호된다.
        4. 패스워드가 암호화되지만 패스워드의 복잡성 설정의 한계가 있기
           때문에 일반적으로 이 방법을 사용하지 않는 것이 좋다.
        5. 자동화된 스크립트를 통해 일반적인 길이의 패스워드는 공격에 의해 해제될 수 있다.
           **가장 많이 사용되고 권장되는 방법은 SSH 키 쌍을 사용하는 것이다.**
           이 방법을 사용하기 위해서는 클라이언트 측에서도 SSH 키 쌍을 생성해야 한다.
           SSH 키 쌍을 통한 클라이언트 인증은 앞서 살펴본 올바를 서버인지 확인하는 과정과 비슷하다.
            1. 클라이언트는 인증할 키 쌍의 ID를 서버에 전송
            2. 서버는 클라이언트가 접속하고자 하는 계정의 .ssh/authorized_keys 파일을 확인
            3. ID에 매칭되는 공개키가 있을 시, 서버는 난수를 생성하고 클라이언트의 공개키로 암호화
            4. 서버는 클라이언트에게 암호화된 메시지 전송
            5. 클라이언트의 개인키를 통해 암호화된 메시지를 복호화하여 난수 추출
            6. 클라이언트는 난수를 세션키와 결합하여 해시값 계산 후 서버 전송
            7. 서버는 저장된 난수와 세션키를 결합하여 해시값 계산 후 비교
            8. 일치할 시 클라이언트 인증

               > 이와 같이 비대칭키를 이용하여
               클라이언트가**개인키를 가지고 있는 정상적인 클라이언트라고 증명**할 수 있다.

>

    ```java
    비대칭키 방식 정리
    
    - 공개키로 암호화한 내용은 공개키로 복호화할 수 없고 개인키로 복호화가 가능하다.
    - 개인키로 암호화한 내용은 개인키로 복호화할 수 없고 공개키로 복호화가 가능하다.
    
    비대칭키 시스템에서 개인키는 자신만 가지고 있는 단일 소유권이고 
    공개키는 여러 사용자가 소유할 수 있는 분산 소유권이다.
    
    두개의 노드가 통신한다고 했을 때 서로의 공개키로 암호화하여 송신한다면, 
    개인키를 가지고 있는 수신자를 제외하고 다른 노드는 통신 내용을 복호화할 수 없다.
    
    그러나 개인키로 암호화하여 송신한다면, 
    공개키를 가지고 있는 모든 노드들이 통신 내용을 복호화할 수 있을 것이다.
    
    그래서 개인키는 메시지에 서명하는 용도로 사용하고 통신 시 암호화에 사용하지 않는다.
    메시지 서명은 작성자가 해시값을 개인키로 암호화하여 
    모든 사용자가 공개키로 해시값을 복호화하고 수신된 해시값과 비교하여 올바른 작성자임을 증명하는 것이다.
    
    (= 공개키 소유자는 서명된 메시지의 출처가 개인키 소유자라는 것을 확인할 수 있다.)
    
    ** 키교환 과정 (Elliptic Curve Diffie-Hellman 방식) **
    
    - 클라이언트와 서버가 서로에게 SSH_MSG_KEX_INIT 메시지를 전송 (암호화 방식 리스트 포함)
    - 양쪽 모두 동일한 알고리즘을 사용하여 암호화 지원 목록에서 선택
    - 클라이언트는 비대칭키 키 쌍(공개키, 개인키) 생성 → 사용 후 삭제 (키 교환에만 사용되고 나중에 폐기)
    - 클라이언트는 SSH_MSG_KEX_ECDH_INIT 메시지를 서버에 전송 (클라이언트 공개키 전송)
    - 서버에서 SSH_MSG_KEX_ECDH_INIT 수신 시 비대칭키 키 쌍(임시) 생성
    - 서버는 클라이언트의 공개키와 자신의 키 쌍으로 대칭키 K 생성
    - 교환할 해시값 생성 (대칭키 포함, 서버의 개인키로 서명) 및 클라이언트로 전송 # 서명을 통해 올바른 서버임을 클라이언트가 확인 가능
    - 클라이언트는 서버로부터 SSH_MSG_KEX_ECDH_REPLY 수신
    - 클라이언트가 서버의 응답으로부터 서버의 공개 키 추출, HS의 서명 확인＃ 로컬에 존재하는 서버 공개키와 추출한 공개키 비교, MITM 공격을 방지하기 위한 서명 확인
    - 클라이언트에서 대칭키 공유
    
    **데이터 암호화를 시작하기 전 새로운 키 생성 (대칭키 K로 충분하지 않음)**
    ```

5. SSH의 보안 항목
    1. **암호화**
       SSH는 모든 데이터 통신을 암호화하여 기밀성을 보호합니다.
       클라이언트와 서버 간의 통신, 사용자 인증 및 데이터 전송은 모두 암호화되어
       중간에서의 도청을 방지합니다.
       암호화는 대칭키 암호화와 공개키 암호화를 사용하여 수행됩니다.
    2. **인증**
       SSH는 사용자의 신원을 인증하기 위한 다양한 방법을 제공합니다.
       가장 일반적인 인증 방법은 비밀번호를 사용한 인증입니다.
       사용자는 비밀번호를 입력하여 접속을 인증할 수 있습니다.
       또한, SSH는 공개키 기반의 인증도 지원합니다. 공개키를 생성하고 서버에 등록한 후,
       클라이언트는 해당 개인키를 사용하여 서버에 안전하게 접속할 수 있습니다.
    3. **서버 신원 확인**
       SSH는 서버의 신원을 확인하여 중간자 공격을 방지합니다.
       클라이언트는 서버의 공개키를 이용하여 서버의 신원을 확인할 수 있습니다.
       이를 통해 클라이언트는 신뢰할 수 있는 서버와 안전한 통신을 수행할 수 있습니다.
    4. **포트 포워딩**
       SSH는 포트 포워딩을 통해 안전한 터널을 생성할 수 있습니다.
       클라이언트는 SSH 연결을 통해 원격 서버의 포트와 로컬 시스템의 포트를 연결하여
       원격 서버의 서비스에 로컬로 접근할 수 있습니다.
       이를 통해 데이터의 안전한 전송과 로컬 시스템에서의 보안 제어가 가능합니다.
    5. **세션 관리**
       SSH는 세션을 관리하고 보안을 유지합니다.
       세션은 클라이언트와 서버 간의 연결을 나타내며,
       SSH는 이러한 세션을 신뢰할 수 있도록 관리하고 보호합니다.
       세션 보안을 유지하기 위해 암호화 키를 주기적으로 갱신하고 재인증을 수행합니다.
    6. **로그 기록**
       SSH는 연결 및 인증 시도와 관련된 로그를 기록합니다.
       이를 통해 보안 사고의 추적 및 감시가 가능하며, 보안 이슈를 신속하게 파악할 수 있습니다.

6. Linxu Terminal에서의 샘플 코드
    1. 원격 서버에 접속하기: **`ssh <사용자명>@<서버 주소>`**

        ```bash
        ssh username@example.com
        ```

    2. Private Key File을 사용하여 원격 서버에 접속하기

        ```java
        #!/bin/bash
        
        # SSH 접속 정보
        HOST="example.com"
        PORT=22
        USER="username"
        PRIVATE_KEY="/path/to/private_key"
        
        # 실행할 명령어
        COMMAND="ls -l"
        
        # SSH 접속 및 명령어 실행
        ssh -i $PRIVATE_KEY -p $PORT $USER@$HOST "$COMMAND"
        ```

    3. 원격 서버에 명령 실행하기: **`ssh <사용자명>@<서버 주소> "<명령어>"`**

        ```bash
        ssh username@example.com "ls -l"
        ```

    4. 원격 서버로 파일 전송하기: **`scp <로컬 파일> <사용자명>@<서버 주소>:<원격 경로>`**

        ```bash
        scp file.txt username@example.com:/path/to/remote/file.txt
        ```

    5. 원격 서버에서 파일 다운로드하기: **`scp <사용자명>@<서버 주소>:<원격 파일> <로컬 경로>`**

        ```bash
        scp username@example.com:/path/to/remote/file.txt /path/to/local/file.txt
        ```


# ****02_Protocol FTP & SSH****

---

## 1. **FTP(File Transfer Protocol)**

1. **FTP란??**

FTP는 파일 전송 프로토콜(File Transfer Protocol)의 약자로,
컴퓨터 네트워크를 통해 파일을 전송하기 위해 사용되는 표준 프로토콜입니다.

    FTP는 클라이언트-서버 모델을 기반으로 작동합니다. 
    클라이언트는 FTP 클라이언트 소프트웨어( FileZilla 등 )를 사용하여 서버로 연결하고, 
    서버는 FTP 서버 소프트웨어를 사용하여 클라이언트의 요청을 처리합니다. 
    이를 통해 파일의 업로드, 다운로드, 삭제, 이동 등의 작업을 수행할 수 있습니다.
    
    FTP는 기본적으로 TCP/IP 프로토콜 스택을 사용하며, 기본 포트 번호는 21번입니다. 
    FTP는 암호화되지 않기 때문에, 보안을 강화하기 위해 
    SSL(Secure Sockets Layer)이나 TLS(Transport Layer Security)와 같은 
    보안 계층을 추가하여 FTPS(File Transfer Protocol Secure)로 사용할 수 있습니다.

2. **명령어와 응답 코드**

FTP는 다양한 명령어와 응답 코드를 사용하여 클라이언트와 서버 간의 상호작용을 담당합니다.
명령어는 클라이언트가 서버에게 보내는 요청을 나타내며,
응답 코드는 서버가 클라이언트에게 반환하는 상태를 나타냅니다.
몇 가지 일반적인 FTP 명령어와 응답 코드는 다음과 같습니다

    1. **USER**: 서버에 사용자 이름을 보내 인증을 위해 사용됩니다.
    2. **PASS**: 서버에 사용자 비밀번호를 보내 인증을 완료합니다.
    3. **LIST**: 서버의 디렉토리 내용을 나열합니다.
    4. **RETR**: 서버에서 파일을 클라이언트로 다운로드합니다.
    5. **STOR**: 클라이언트에서 서버로 파일을 업로드합니다.
    6. **DELE**: 서버에서 파일을 삭제합니다.
    7. **MKD**: 서버에 새 디렉토리를 생성합니다.
    8. **RMD**: 서버에서 디렉토리를 삭제합니다.

3. Linxu Terminal 에서의 샘플 코드
    1. Linux 터미널에서 FTP를 사용하기 위해선 **`ftp`** 명령어를 사용할 수 있습니다.
    2. 서버에 연결하기: **`ftp <서버 주소>`**

        ```bash
        ftp [example.com](http://example.com/)
        ```

    3. 사용자 인증 : `user <사용자 이름> <비밀번호>`

        ```bash
        user username password
        ```

    4. 서버의 현재 디렉토리 내용 나열 : `ls`

        ```bash
        ls
        ```

    5. 파일 다운로드: **`get <원격 파일> [<로컬 파일>]`**

        ```bash
        get file.txt
        ```

    6. 파일 업로드: **`put <로컬 파일> [<원격 파일>]`**

        ```bash
        put file.txt
        ```

    7. 서버와의 연결 종료: **`bye`**

        ```bash
        bye
        ```


4. Java Sample Code ( Apache Commons Net )

    ```java
    import org.apache.commons.net.ftp.FTP;
    import org.apache.commons.net.ftp.FTPClient;
    
    import java.io.*;
    
    public class FTPExample {
        public static void main(String[] args) {
            // 연결할 FTP 서버의 호스트 주소
            String server = "ftp.example.com";
            // FTP 서버의 포트
            int port = 21;
            // 사용자 정보
            String user = "username";
            String pass = "password";
            // FTP Client 객체 생성
            FTPClient ftpClient = new FTPClient();
    
            try {
                // FTP 서버에 연결
                ftpClient.connect(server, port);
                // 사용자 인증
                ftpClient.login(user, pass);
    
                // Passive 모드로 설정
                ftpClient.enterLocalPassiveMode();
                // 전송 파일 유형 설정 (BINARY_FILE_TYPE은 이진 파일 전송을 의미)
                ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
    
                // 다운로드할 원격 파일 경로와 로컬 파일 객체 생성
                String remoteFile = "/path/to/remote/file.txt";
                File localFile = new File("/path/to/local/file.txt");
    
                // 로컬 파일로 데이터를 전송받기 위한 OutputStream 생성
                OutputStream outputStream = new BufferedOutputStream(new FileOutputStream(localFile));
                // 원격 파일을 로컬 파일로 다운로드
                boolean success = ftpClient.retrieveFile(remoteFile, outputStream);
                outputStream.close();
    
                // 다운로드 성공 여부 확인
                if (success) {
                    System.out.println("File has been downloaded successfully.");
                }
            } catch (IOException e) {
                e.printStackTrace();
            } finally {
                try {
                    // FTP 연결 종료
                    if (ftpClient.isConnected()) {
                        ftpClient.logout();
                        ftpClient.disconnect();
                    }
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
    ```


## 2. **SSH ( Secure Shell )**

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ff926644-8e47-4d9f-b924-e0c300acdb7e/Untitled.webp)

1. SSH란??

   SSH는 Secure Shell의 약자로,
   네트워크를 통해 안전하게 원격으로 로그인하고 컴퓨터를 제어하기 위한 프로토콜 및
   해당 프로토콜을 구현한 프로그램입니다.

   SSH는 암호화 기술을 사용하여 네트워크 연결을 보호합니다.
   이를 통해 사용자는 원격으로 안전하게 서버에 로그인하고 명령을 실행할 수 있습니다.
   SSH는 클라이언트-서버 모델을 기반으로 작동하며, 일반적으로 22번 포트를 사용합니다.

   SSH는 데이터 전송, 원격 제어, 파일 전송 등 다양한 용도로 사용됩니다.
   SSH는 비밀번호 인증뿐만 아니라 공개 키 인증 방식도 지원하여 보안성을 강화할 수 있습니다.
   SSH는 네트워크 보안을 위해 광범위하게 사용되며,
   FTP와 달리 데이터를 암호화하여 안전한 전송을 보장합니다.

   SSH는 다양한 운영체제에서 지원되며, 주로 Linux 및 Unix 시스템에서 널리 사용됩니다.
   SSH 클라이언트 및 서버는 OpenSSH, PuTTY, SecureCRT 등 다양한 소프트웨어로 구현되어 있습니다.

2. SSH 주요 기능
    1. **보안 연결**
       SSH는 암호화 기술을 사용하여 클라이언트와 서버 간의 통신을 암호화합니다.
       이를 통해 데이터의 기밀성과 무결성을 보호하며 중간에서의 도청이나 데이터 변조를 방지합니다.
    2. **사용자 인증**
       SSH는 비밀번호 인증뿐만 아니라 공개 키 기반의 인증 방식도 지원합니다.
       공개 키를 사용한 인증은 보안성을 높이고 비밀번호를 입력하지 않고도 안전하게 로그인할 수 있습니다.
    3. **원격 제어**
       SSH를 사용하면 원격 서버에 접속하여 명령을 실행하고 원격으로 컴퓨터를 제어할 수 있습니다.
       SSH 클라이언트를 사용하여 원격 서버에 로그인하면
       원격 환경에서 명령어를 실행하거나 파일을 조작할 수 있습니다.
    4. **파일 전송**
       SSH는 파일 전송을 위한 SCP(Secure Copy)와 SFTP(SSH File Transfer Protocol)를 지원합니다. 이를 통해 파일을 안전하게 원격 서버로 전송하거나 원격 서버에서 로컬로 다운로드할 수 있습니다.

3. SSH 동작 원리
    1. SSH 프로토콜은 클라이언트-서버 모델로 동작하며 
    **대칭키 방식, 비대칭키 방식, 해시 알고리즘을 사용**하여 인증 및 암호화를 수행한다.
    2. **대칭키 방식은 클라이언트-서버 간 전체 연결을 암호화에 사용**되며
    3. **비대칭키 방식은 키 교환, 클라이언트 인증, 서버 인증에 사용**되고,
    4. **해시 알고리즘은 패킷의 무결성을 확인하기 위해 사용**된다.
       (HMAC : Hash based Message Authenticated Codes)

4. SSH 동작 과정
    1. **클라이언트는 서버에 원격 접속하기 위해 연결을 설정하는 프로세스를 시작한다.**
        1. SSH 프로토콜은 기본적(Default)으로 TCP 22번 포트를 사용하여 통신한다.
        2. 클라이언트가 서버에 원격 접속하기 위해
           서버의 TCP 22번 포트로 SSH 접속 요청을 보내는 것이 SSH 연결의 첫 단계이다.
        3. 서버는 클라이언트에게 서버가 지원하는 프로토콜의 버전을 응답으로 보내준다.
        4. 클라이언트는 **서버가 지원하는 프로토콜의 버전 중
           자신과 일치하는 것이 있다면 연결을 지속**한다. **(버전 교환)**

    2. **서버는 자신의 공개키를 클라이언트에게 전송한다.**
        1. 서버는 클라이언트로부터 SSH 접속 요청을 받고
           자신의 공개키를 클라이언트에게 응답하고
           클라이언트는 서버로부터 받은 공개키를 로컬에 저장한다.
        2. 클라이언트는 원격 접속하는 서버들의 공개키를
           로컬 사용자 홈 디렉터리의 .ssh 경로 내의 known_hosts 파일에 저장하고 있다.

            ```
            ※ 클라이언트 사용자의 known_hosts 경로(Default)
            
            <Linux>
            일반계정  : /home/USER/.ssh/known_hosts
            root 계정 : /root/.ssh/known_hosts
            
            <Window>
            사용자    : %USERNAME%\.ssh\known_hosts
            ```

    3. **클라이언트와 서버는 여러 Parameter들을 주고 받으며 보안 채널을 확립한다.**
        1. **[ Client 1 ] 올바른 서버인지 확인**
            1. 클라이언트는 SSH로 원격 접속하려고 하는 서버가 올바른 서버인지 확인할 필요가 있다.
            2. 이를 위해 클라이언트는 known_hosts 파일에 존재하는 
            서버의 공개키를 통해 정상적인 서버인지 확인하는 작업을 수행한다.
            3. 확인 단계는 다음과 같다.
                1. 클라이언트에서 난수 생성, 난수 해시값 생성 및 저장
                2. 난수를 서버의 공개키로 암호화 후 서버에 전송
                3. 서버에서 서버의 개인키로 데이터를 복호화하여 난수 추출
                4. 서버에서 복호화된 난수 해시값을 생성 후 클라이언트에게 전송
                5. 클라이언트에 저장된 난수 해시값과 서버에서 받은 난수 해시값을 비교
                6. 동일할 시 올바른 서버 확인

        2. **[ Client 2 ] 암호화된 통신을 위한 세션키 생성 (대칭키 생성)**
            1. **세션키는 대칭키**로 전체 세션을 암호화하는데 사용되며 **모든 통신을 암호화** 한다.
            2. 대칭키는 비대칭키에 비해 빠르고 컴퓨팅 파워가 더 적게 든다는 장점을 가지고 있다.
            3. 그러나 대칭키가 유출되었을 경우
               공격자가 암호화된 모든 통신을 복호화할 수 있는 치명적인 문제점을 가지고 있다.
            4. 이를 해결하기 위해 클라이언트와 서버는
               **키 교환 알고리즘**을 통해 안전하게 대칭키를 공유한다.

               > **디피-헬만( Diffie-Hellman / DH ) Algorithm**
               >
               > 1. SSH에서 사용하는 대표적인 **키교환 알고리즘인 DH 알고리즘**은
                    > 상대방의 공개키(비대칭 키)와 나의 개인키를 통해 대칭키를 얻어내는 방법이다.
            5. 클라이언트와 서버는
               임시 공개키( 임시 개인키와 해당 개인키에 대한 공개키 ) 방식의 키 쌍을 생성합니다.
               이 과정에서 클라이언트와 서버는 각자의 개인키와 공개키를 생성합니다.
            6. 클라이언트는 자신의 공개키를 서버에게 전달하고,
               서버는 자신의 공개키를 클라이언트에게 전달합니다.
               이를 통해 상대방의 공개키를 얻을 수 있습니다.
            7. 클라이언트는 상대방의 공개키와 자신의 개인키를 사용하여
               공유 비밀값(Shared Secret)을 계산합니다.
               이 비밀값은 대칭키로 사용될 수 있는데,
               클라이언트와 서버는 동일한 비밀값을 얻게 됩니다.
            8. 클라이언트와 서버는 얻어낸 공유 비밀값을 대칭키인 세션키로 사용하여
               암호화된 통신을 수행합니다.
               이후 모든 데이터는 대칭키를 사용하여 암호화되고 복호화됩니다.

               즉, DH 알고리즘을 통해 클라이언트와 서버는
               상대방의 공개키와 자신의 개인키를 이용하여 공유 비밀값을 계산하고,
               이 비밀값을 대칭키로 사용하여 통신을 암호화합니다.
               이로써 클라이언트와 서버는 대칭키인 세션키를 공유하게 되는 것입니다.

            9. **[주의] 대칭키 교환에 사용되는 키 쌍은
               서버와 클라이언트 인증에 사용되는 SSH 키 쌍과 다름**

               > SSH가 DH를 통해 얻은 대칭키는 
                **개별 세션에 대해 생성되며 더 이상 필요하지 않은 즉시 사라진다.**
               >
               >
               > 따라서 클라이언트나 서버의 개인키가 유출되어도
               > 이전 세션키를 통해 수행한 통신 내용을 복호화할 수 없다.
               >
               > 이는 TLS 세션에서도 사용되는 구성으로 인증서에 만료 날짜가 있는 경우
               > 개인키는 중간자 공격으로 인해 유출되어도 인증서가 만료되었을 시
               > 사용할 수 없으므로 만료 후에는 강한 보안 유지를 하지 않아도 된다
    >

    4. **[ Server ]** **서버에 접근할 수 있는 클라이언트인지 확인**
        1. 서버 또한 자신에게 접속하려는 클라이언트가
           자신에게 접근할 수 있는 권한이 있는지 확인하는 단계가 필요하다.
        2. 가장 간단한 방법으로 **패스워드 인증**이 있다.
        3. 서버는 단순히 로그인하려는 계정의 암호를 묻고
           클라이언트가 입력한 비밀번호는 세션키를 통해 암호화되고 전송되어
           외부로부터 안전하게 보호된다.
        4. 패스워드가 암호화되지만 패스워드의 복잡성 설정의 한계가 있기
           때문에 일반적으로 이 방법을 사용하지 않는 것이 좋다.
        5. 자동화된 스크립트를 통해 일반적인 길이의 패스워드는 공격에 의해 해제될 수 있다.
           **가장 많이 사용되고 권장되는 방법은 SSH 키 쌍을 사용하는 것이다.**
           이 방법을 사용하기 위해서는 클라이언트 측에서도 SSH 키 쌍을 생성해야 한다.
           SSH 키 쌍을 통한 클라이언트 인증은 앞서 살펴본 올바를 서버인지 확인하는 과정과 비슷하다.
            1. 클라이언트는 인증할 키 쌍의 ID를 서버에 전송
            2. 서버는 클라이언트가 접속하고자 하는 계정의 .ssh/authorized_keys 파일을 확인
            3. ID에 매칭되는 공개키가 있을 시, 서버는 난수를 생성하고 클라이언트의 공개키로 암호화
            4. 서버는 클라이언트에게 암호화된 메시지 전송
            5. 클라이언트의 개인키를 통해 암호화된 메시지를 복호화하여 난수 추출
            6. 클라이언트는 난수를 세션키와 결합하여 해시값 계산 후 서버 전송
            7. 서버는 저장된 난수와 세션키를 결합하여 해시값 계산 후 비교
            8. 일치할 시 클라이언트 인증

               > 이와 같이 비대칭키를 이용하여
               클라이언트가 **개인키를 가지고 있는 정상적인 클라이언트라고 증명**할 수 있다.
>


    ```java
    비대칭키 방식 정리
    
    - 공개키로 암호화한 내용은 공개키로 복호화할 수 없고 개인키로 복호화가 가능하다.
    - 개인키로 암호화한 내용은 개인키로 복호화할 수 없고 공개키로 복호화가 가능하다.
    
    비대칭키 시스템에서 개인키는 자신만 가지고 있는 단일 소유권이고 
    공개키는 여러 사용자가 소유할 수 있는 분산 소유권이다.
    
    두개의 노드가 통신한다고 했을 때 서로의 공개키로 암호화하여 송신한다면, 
    개인키를 가지고 있는 수신자를 제외하고 다른 노드는 통신 내용을 복호화할 수 없다.
    
    그러나 개인키로 암호화하여 송신한다면, 
    공개키를 가지고 있는 모든 노드들이 통신 내용을 복호화할 수 있을 것이다.
    
    그래서 개인키는 메시지에 서명하는 용도로 사용하고 통신 시 암호화에 사용하지 않는다.
    메시지 서명은 작성자가 해시값을 개인키로 암호화하여 
    모든 사용자가 공개키로 해시값을 복호화하고 수신된 해시값과 비교하여 올바른 작성자임을 증명하는 것이다.
    
    (= 공개키 소유자는 서명된 메시지의 출처가 개인키 소유자라는 것을 확인할 수 있다.)
    
    ** 키교환 과정 (Elliptic Curve Diffie-Hellman 방식) **
    
    - 클라이언트와 서버가 서로에게 SSH_MSG_KEX_INIT 메시지를 전송 (암호화 방식 리스트 포함)
    - 양쪽 모두 동일한 알고리즘을 사용하여 암호화 지원 목록에서 선택
    - 클라이언트는 비대칭키 키 쌍(공개키, 개인키) 생성 → 사용 후 삭제 (키 교환에만 사용되고 나중에 폐기)
    - 클라이언트는 SSH_MSG_KEX_ECDH_INIT 메시지를 서버에 전송 (클라이언트 공개키 전송)
    - 서버에서 SSH_MSG_KEX_ECDH_INIT 수신 시 비대칭키 키 쌍(임시) 생성
    - 서버는 클라이언트의 공개키와 자신의 키 쌍으로 대칭키 K 생성
    - 교환할 해시값 생성 (대칭키 포함, 서버의 개인키로 서명) 및 클라이언트로 전송 # 서명을 통해 올바른 서버임을 클라이언트가 확인 가능
    - 클라이언트는 서버로부터 SSH_MSG_KEX_ECDH_REPLY 수신
    - 클라이언트가 서버의 응답으로부터 서버의 공개 키 추출, HS의 서명 확인＃ 로컬에 존재하는 서버 공개키와 추출한 공개키 비교, MITM 공격을 방지하기 위한 서명 확인
    - 클라이언트에서 대칭키 공유
    
    **데이터 암호화를 시작하기 전 새로운 키 생성 (대칭키 K로 충분하지 않음)**
    ```

5. SSH의 보안 항목
    1. **암호화**
       SSH는 모든 데이터 통신을 암호화하여 기밀성을 보호합니다.
       클라이언트와 서버 간의 통신, 사용자 인증 및 데이터 전송은 모두 암호화되어
       중간에서의 도청을 방지합니다.
       암호화는 대칭키 암호화와 공개키 암호화를 사용하여 수행됩니다.
    2. **인증**
       SSH는 사용자의 신원을 인증하기 위한 다양한 방법을 제공합니다.
       가장 일반적인 인증 방법은 비밀번호를 사용한 인증입니다.
       사용자는 비밀번호를 입력하여 접속을 인증할 수 있습니다.
       또한, SSH는 공개키 기반의 인증도 지원합니다. 공개키를 생성하고 서버에 등록한 후,
       클라이언트는 해당 개인키를 사용하여 서버에 안전하게 접속할 수 있습니다.
    3. **서버 신원 확인**
       SSH는 서버의 신원을 확인하여 중간자 공격을 방지합니다.
       클라이언트는 서버의 공개키를 이용하여 서버의 신원을 확인할 수 있습니다.
       이를 통해 클라이언트는 신뢰할 수 있는 서버와 안전한 통신을 수행할 수 있습니다.
    4. **포트 포워딩**
       SSH는 포트 포워딩을 통해 안전한 터널을 생성할 수 있습니다.
       클라이언트는 SSH 연결을 통해 원격 서버의 포트와 로컬 시스템의 포트를 연결하여
       원격 서버의 서비스에 로컬로 접근할 수 있습니다.
       이를 통해 데이터의 안전한 전송과 로컬 시스템에서의 보안 제어가 가능합니다.
    5. **세션 관리**
       SSH는 세션을 관리하고 보안을 유지합니다.
       세션은 클라이언트와 서버 간의 연결을 나타내며,
       SSH는 이러한 세션을 신뢰할 수 있도록 관리하고 보호합니다.
       세션 보안을 유지하기 위해 암호화 키를 주기적으로 갱신하고 재인증을 수행합니다.
    6. **로그 기록**
       SSH는 연결 및 인증 시도와 관련된 로그를 기록합니다.
       이를 통해 보안 사고의 추적 및 감시가 가능하며, 보안 이슈를 신속하게 파악할 수 있습니다.

6. Linxu Terminal에서의 샘플 코드
    1. 원격 서버에 접속하기: **`ssh <사용자명>@<서버 주소>`**

        ```bash
        ssh username@example.com
        ```

    2. Private Key File을 사용하여 원격 서버에 접속하기

        ```java
        #!/bin/bash
        
        # SSH 접속 정보
        HOST="example.com"
        PORT=22
        USER="username"
        PRIVATE_KEY="/path/to/private_key"
        
        # 실행할 명령어
        COMMAND="ls -l"
        
        # SSH 접속 및 명령어 실행
        ssh -i $PRIVATE_KEY -p $PORT $USER@$HOST "$COMMAND"
        ```

    3. 원격 서버에 명령 실행하기: **`ssh <사용자명>@<서버 주소> "<명령어>"`**

        ```bash
        ssh username@example.com "ls -l"
        ```

    4. 원격 서버로 파일 전송하기: **`scp <로컬 파일> <사용자명>@<서버 주소>:<원격 경로>`**

        ```bash
        scp file.txt username@example.com:/path/to/remote/file.txt
        ```

    5. 원격 서버에서 파일 다운로드하기: **`scp <사용자명>@<서버 주소>:<원격 파일> <로컬 경로>`**

        ```bash
        scp username@example.com:/path/to/remote/file.txt /path/to/local/file.txt
        ```

7. Java Sample Code
```java
import com.jcraft.jsch.*;

public class SSHKeyExample {
    public static void main(String[] args) {
        // SSH 서버 정보
        String host = "example.com";
        int port = 22;
        String user = "username";
        String privateKeyPath = "/path/to/private_key";

        try {
            // JSch 객체 생성
            JSch jsch = new JSch();

            // Key 파일 로드
            jsch.addIdentity(privateKeyPath);

            // SSH 세션 생성
            Session session = jsch.getSession(user, host, port);
            session.setConfig("StrictHostKeyChecking", "no");
            session.connect();

            // 실행할 명령어
            String command = "ls -l";
            
            // SSH 채널 생성 및 명령어 설정
            Channel channel = session.openChannel("exec");
            ((ChannelExec) channel).setCommand(command);
            channel.setInputStream(null);
            ((ChannelExec) channel).setErrStream(System.err);

            // 명령어 실행 결과를 읽어들일 InputStream 생성
            InputStream inputStream = channel.getInputStream();
            channel.connect();

            byte[] buffer = new byte[1024];
            StringBuilder output = new StringBuilder();
            while (inputStream.read(buffer) != -1) {
                output.append(new String(buffer));
            }

            // SSH 연결 종료
            channel.disconnect();
            session.disconnect();

            System.out.println("Command executed successfully. Output:");
            System.out.println(output.toString());
        } catch (JSchException | IOException e) {
            e.printStackTrace();
        }
    }
}
```